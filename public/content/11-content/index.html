<!DOCTYPE html>
<html lang="en-us" 
      xmlns:og="http://ogp.me/ns#" 
      xmlns:fb="https://www.facebook.com/2008/fbml">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.8.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Ben Bushong">

  
  
  
    
  
  <meta name="description" content="Required ReadingGuiding QuestionsIntroduction to data wranglingReshaping datagatherspreadseparateuniteJoining tablesJoinsLeft joinRight joinInner joinFull joinSemi joinAnti joinBindingBinding columnsBinding by rowsSet operatorsIntersectUnionsetdiffsetequalA note about merging and dupliacted rowsParsing dates and timesThe date data typeThe lubridate packageRequired ReadingThis page.">

  
  <link rel="alternate" hreflang="en-us" href="https://datavizm20.classes.andrewheiss.com/content/11-content/">

  


  
  
  
  <meta name="theme-color" content="#18453B">
  

  
  
  
  <script src="/js/mathjax-config.js"></script>
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-1/css/all.min.css" integrity="sha256-4w9DunooKSr3MFXHXWyFER38WmPdm361bQS/2KUWZbU=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Condensed:400,400i,700,700i%7COverpass:400,400i,700,700i&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="https://datavizm20.classes.andrewheiss.com/content/11-content/">

  
  
  
  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="Data Analytics">
  <meta property="og:url" content="https://datavizm20.classes.andrewheiss.com/content/11-content/">
  <meta property="og:title" content="Data Wrangling | Data Analytics">
  <meta property="og:description" content="Required ReadingGuiding QuestionsIntroduction to data wranglingReshaping datagatherspreadseparateuniteJoining tablesJoinsLeft joinRight joinInner joinFull joinSemi joinAnti joinBindingBinding columnsBinding by rowsSet operatorsIntersectUnionsetdiffsetequalA note about merging and dupliacted rowsParsing dates and timesThe date data typeThe lubridate packageRequired ReadingThis page."><meta property="og:image" content="https://datavizm20.classes.andrewheiss.com/img/social-image.png">
  <meta property="twitter:image" content="https://datavizm20.classes.andrewheiss.com/img/social-image.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2022-03-28T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2021-04-04T08:07:06-04:00">
  

  



  


  


  <link rel="shortcut icon" href="https://datavizm20.classes.andrewheiss.com/favicon.ico" />
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://datavizm20.classes.andrewheiss.com/img/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="https://datavizm20.classes.andrewheiss.com/img/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="https://datavizm20.classes.andrewheiss.com/img/favicon-16x16.png" sizes="16x16" />
  <meta name="application-name" content="SSC 442: Data Analytics" />
  <meta name="msapplication-TileColor" content="#FFFFFF" />
  <meta name="msapplication-TileImage" content="https://datavizm20.classes.andrewheiss.com/img/mstile-144x144.png" />


  <title>Data Wrangling | Data Analytics</title>

</head>


<body id="top" data-spy="scroll" data-offset="70"
    data-target="#TableOfContents"
    >

    <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


    







<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Data Analytics</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Data Analytics</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-end" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/syllabus/"><span>Syllabus</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/schedule/"><span>Schedule</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/content/"><span>Content</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/example/"><span>Examples</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/assignment/"><span>Assignments</span></a>
        </li>

        
        

        

        
        
        
          
            
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="https://join.slack.com/t/ssc442kirkpatrick/shared_invite/zt-kxhgemgn-vaEGD_4KcpDCOEJtXxbxbQ" target="_blank" rel="noopener"><span><i class="fab fa-slack"></i></span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      

      

      

    </ul>

  </div>
</nav>


    

<div class="container-fluid docs">
    <div class="row flex-xl-nowrap">
        <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
            





  
    
  




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
</form>

<nav class="collapse docs-links" id="docs-nav">
  

  
  
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/content/">Readings, lectures, and videos</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/content/00-content/">Course content</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/content/00-content/">0: Introduction to R</a>
      </li>
      
      <li >
        <a href="/content/01-content/">1: The Tidyverse</a>
      </li>
      
      <li >
        <a href="/content/02-content/">2: Visualization</a>
      </li>
      
      <li >
        <a href="/content/03-content/">3: Visualization II</a>
      </li>
      
      <li >
        <a href="/content/04-content/">4: Uncertainty</a>
      </li>
      
      <li >
        <a href="/content/05-content/">5: Linear Regression I</a>
      </li>
      
      <li >
        <a href="/content/06-content/">6: Linear Regression II</a>
      </li>
      
      <li >
        <a href="/content/07-content/">7: Linear Regression III</a>
      </li>
      
      <li >
        <a href="/content/08-content/">8: Nonparametric Regression</a>
      </li>
      
      <li >
        <a href="/content/09-content/">9: Bias vs. Variance</a>
      </li>
      
      <li >
        <a href="/content/10-content/">10: Classification</a>
      </li>
      
      <li class="active">
        <a href="/content/11-content/">11: Data Wrangling</a>
      </li>
      
      <li >
        <a href="/content/12-content/">12: Text as Data</a>
      </li>
      
      <li >
        <a href="/content/13-content/">13: Geospatial with R</a>
      </li>
      
    </ul>
    

  </div>
  
  
</nav>

        </div>

        

        <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

            <article class="article">

                <div class="docs-article-container">
                    <h1>Data Wrangling</h1>

                    

                    
                    <div class="due-date p-2 mb-3 bg-content text-white">
                        Content for Tuesday, April 5, 2022
                    </div>
                    

                    

                    <div class="article-style">
                        

<div id="TOC">
<ul>
<li><a href="#required-reading">Required Reading</a><ul>
<li><a href="#guiding-questions">Guiding Questions</a></li>
</ul></li>
<li><a href="#introduction-to-data-wrangling">Introduction to data wrangling</a></li>
<li><a href="#reshaping-data">Reshaping data</a><ul>
<li><a href="#gather"><code>gather</code></a></li>
<li><a href="#spread"><code>spread</code></a></li>
<li><a href="#separate"><code>separate</code></a></li>
<li><a href="#unite"><code>unite</code></a></li>
</ul></li>
<li><a href="#joining-tables">Joining tables</a><ul>
<li><a href="#joins">Joins</a><ul>
<li><a href="#left-join">Left join</a></li>
<li><a href="#right-join">Right join</a></li>
<li><a href="#inner-join">Inner join</a></li>
<li><a href="#full-join">Full join</a></li>
<li><a href="#semi-join">Semi join</a></li>
<li><a href="#anti-join">Anti join</a></li>
</ul></li>
<li><a href="#binding">Binding</a><ul>
<li><a href="#binding-columns">Binding columns</a></li>
<li><a href="#binding-by-rows">Binding by rows</a></li>
</ul></li>
<li><a href="#set-operators">Set operators</a><ul>
<li><a href="#intersect">Intersect</a></li>
<li><a href="#union">Union</a></li>
<li><a href="#setdiff"><code>setdiff</code></a></li>
<li><a href="#setequal"><code>setequal</code></a></li>
</ul></li>
<li><a href="#a-note-about-merging-and-dupliacted-rows">A note about merging and dupliacted rows</a></li>
</ul></li>
<li><a href="#parsing-dates-and-times">Parsing dates and times</a><ul>
<li><a href="#the-date-data-type">The date data type</a></li>
<li><a href="#lubridate">The lubridate package</a></li>
</ul></li>
</ul>
</div>

<div id="required-reading" class="section level2">
<h2>Required Reading</h2>
<ul>
<li>This page.</li>
</ul>
<div id="guiding-questions" class="section level3">
<h3>Guiding Questions</h3>
<ul>
<li>How can we reshape data into a useable <code>tidy</code> form?</li>
<li>What is a <em>join</em> and why is it a common data wrangling maneuver?</li>
<li>What is a <em>primary key</em> and why is it important to think about our data in this way?</li>
<li>How do we deal with messy date variables?</li>
</ul>
</div>
</div>
<div id="introduction-to-data-wrangling" class="section level1">
<h1>Introduction to data wrangling</h1>
<p>Many of the datasets used in this class have been made available to you as <code>R</code> objects, specifically as data frames. The US murders data, the reported heights data, and the Gapminder data were all data frames. Furthermore, much of the data is available in what is referred to as <code>tidy</code> form. The tidyverse packages and functions assume that the data is <code>tidy</code> and this assumption is a big part of the reason these packages work so well together.</p>
<p>However, very rarely in a data science project is data easily available as part of a package. People did quite a bit of work “behind the scenes” to get the original raw data into the <em>tidy</em> tables. Much more typical is for the data to be in a file, a database, or extracted from a document, including web pages, tweets, or PDFs. In these cases, the first step is to import the data into <code>R</code> and, when using the <strong>tidyverse</strong>, tidy up the data. This initial step in the data analysis process usually involves several, often complicated, steps to convert data from its raw form to the <em>tidy</em> form that greatly facilitates the rest of the analysis. We refer to this process as <code>data wrangling</code>.</p>
<p>Here we cover several common steps of the data wrangling process including tidying data, string processing, html parsing, working with dates and times, and text mining. Rarely are <strong>all</strong> these wrangling steps necessary in a single analysis, but data scientists will likely face them all at some point.</p>
</div>
<div id="reshaping-data" class="section level1">
<h1>Reshaping data</h1>
<p>As we have seen through the class, having data in <em>tidy</em> format is what makes the tidyverse flow. After the first step in the data analysis process, importing data, a common next step is to reshape the data into a form that facilitates the rest of the analysis. The <strong>tidyr</strong> package includes several functions that are useful for tidying data.</p>
<pre class="r"><code>library(tidyverse)
library(dslabs)
path &lt;- system.file(&quot;extdata&quot;, package=&quot;dslabs&quot;)
filename &lt;- file.path(path, &quot;fertility-two-countries-example.csv&quot;)
wide_data &lt;- read_csv(filename)</code></pre>
<div id="gather" class="section level2">
<h2><code>gather</code></h2>
<p>One of the most used functions in the <strong>tidyr</strong> package is <code>gather</code>, which is useful for converting wide data into tidy data.</p>
<p>As with most tidyverse functions, the <code>gather</code> function’s first argument is the data frame that will be converted. Here we want to reshape the <code>wide_data</code> dataset so that each row represents a fertility observation, which implies we need three columns to store the year, country, and the observed value. In its current form, data from different years are in different columns with the year values stored in the column names. Through the second and third argument we will tell <code>gather</code> the column names we want to assign to the columns containing the current column names and observations, respectively. In this case a good choice for these two arguments would be <code>year</code> and <code>fertility</code>. Note that nowhere in the data file does it tell us this is fertility data. Instead, we deciphered this from the file name. Through the fourth argument we specify the columns containing observed values; these are the columns that will be <em>gathered</em>. The default is to gather all columns so, in most cases, we have to specify the columns. In our example we want columns <code>1960</code>, <code>1961</code> up to <code>2015</code>.</p>
<p>The code to gather the fertility data therefore looks like this:</p>
<pre class="r"><code>new_tidy_data &lt;- gather(wide_data, year, fertility, `1960`:`2015`)</code></pre>
<p>We can also use the pipe like this:</p>
<pre class="r"><code>new_tidy_data &lt;- wide_data %&gt;% gather(year, fertility, `1960`:`2015`)</code></pre>
<p>We can see that the data have been converted to tidy format with columns <code>year</code> and <code>fertility</code>:</p>
<pre class="r"><code>head(new_tidy_data)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     year  fertility
##   &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;
## 1 Germany     1960       2.41
## 2 South Korea 1960       6.16
## 3 Germany     1961       2.44
## 4 South Korea 1961       5.99
## 5 Germany     1962       2.47
## 6 South Korea 1962       5.79</code></pre>
<p>and that each year resulted in two rows since we have two countries and this column was not gathered.
A somewhat quicker way to write this code is to specify which column will <strong>not</strong> be gathered, rather than all the columns that will be gathered:</p>
<pre class="r"><code>new_tidy_data &lt;- wide_data %&gt;%
  gather(year, fertility, -country)</code></pre>
<p>The <code>new_tidy_data</code> object looks like the original <code>tidy_data</code> we defined this way</p>
<pre class="r"><code>data(&quot;gapminder&quot;)
tidy_data &lt;- gapminder %&gt;%
  dplyr::filter(country %in% c(&quot;South Korea&quot;, &quot;Germany&quot;) &amp; !is.na(fertility)) %&gt;%
  dplyr::select(country, year, fertility)</code></pre>
<p>with just one minor difference. Can you spot it? Look at the data type of the year column:</p>
<pre class="r"><code>class(tidy_data$year)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>class(new_tidy_data$year)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>The <code>gather</code> function assumes that column names are characters. So we need a bit more wrangling before we are ready to make a plot. We need to convert the year column to be numbers. The <code>gather</code> function includes the <code>convert</code> argument for this purpose:</p>
<pre class="r"><code>new_tidy_data &lt;- wide_data %&gt;%
  gather(year, fertility, -country, convert = TRUE)
class(new_tidy_data$year)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>Note that we could have also used the <code>mutate</code> and <code>as.numeric</code>.</p>
<p>Now that the data is tidy, we can use this relatively simple ggplot code:</p>
<pre class="r"><code>new_tidy_data %&gt;% ggplot(aes(year, fertility, color = country)) +
  geom_point()</code></pre>
</div>
<div id="spread" class="section level2">
<h2><code>spread</code></h2>
<p>As we will see in later examples, it is sometimes useful for data wrangling purposes to convert tidy data into wide data. We often use this as an intermediate step in tidying up data. The <code>spread</code> function is basically the inverse of <code>gather</code>. The first argument is for the data, but since we are using the pipe, we don’t show it. The second argument tells <code>spread</code> which variable will be used as the column names. The third argument specifies which variable to use to fill out the cells:</p>
<pre class="r"><code>new_wide_data &lt;- new_tidy_data %&gt;% spread(year, fertility)
dplyr::select(new_wide_data, country, `1960`:`1967`)</code></pre>
<pre><code>## # A tibble: 2 x 9
##   country     `1960` `1961` `1962` `1963` `1964` `1965` `1966` `1967`
##   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Germany       2.41   2.44   2.47   2.49   2.49   2.48   2.44   2.37
## 2 South Korea   6.16   5.99   5.79   5.57   5.36   5.16   4.99   4.85</code></pre>
<p>The following diagram can help remind you how these two functions work:</p>
<p><img src="/./11-content_files/gather-spread.png" /></p>
<p><img src="img/gather-spread.png" /></p>
<p>(Image courtesy of RStudio<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. CC-BY-4.0 license<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. Cropped from original.)
<!-- (Source: RStudio. The image is a section of this [cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf).)--></p>
</div>
<div id="separate" class="section level2">
<h2><code>separate</code></h2>
<p>The data wrangling shown above was simple compared to what is usually required. In our example spreadsheet files, we include an illustration that is slightly more complicated. It contains two variables: life expectancy and fertility. However, the way it is stored is not tidy and, as we will explain, not optimal.</p>
<pre class="r"><code>path &lt;- system.file(&quot;extdata&quot;, package = &quot;dslabs&quot;)

filename &lt;- &quot;life-expectancy-and-fertility-two-countries-example.csv&quot;
filename &lt;-  file.path(path, filename)

raw_dat &lt;- read_csv(filename)
dplyr::select(raw_dat, 1:5)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   country  `1960_fertility` `1960_life_expec~ `1961_fertility` `1961_life_expec~
##   &lt;chr&gt;               &lt;dbl&gt;             &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;
## 1 Germany              2.41              69.3             2.44              69.8
## 2 South K~             6.16              53.0             5.99              53.8</code></pre>
<p>First, note that the data is in wide format. Second, notice that this table includes values for two variables, fertility and life expectancy, with the column name encoding which column represents which variable. Encoding information in the column names is not recommended but, unfortunately, it is quite common. We will put our wrangling skills to work to extract this information and store it in a tidy fashion.</p>
<p>We can start the data wrangling with the <code>gather</code> function, but we should no longer use the column name <code>year</code> for the new column since it also contains the variable type. We will call it <code>key</code>, the default, for now:</p>
<pre class="r"><code>dat &lt;- raw_dat %&gt;% gather(key, value, -country)
head(dat)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     key                  value
##   &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;
## 1 Germany     1960_fertility        2.41
## 2 South Korea 1960_fertility        6.16
## 3 Germany     1960_life_expectancy 69.3 
## 4 South Korea 1960_life_expectancy 53.0 
## 5 Germany     1961_fertility        2.44
## 6 South Korea 1961_fertility        5.99</code></pre>
<p>The result is not exactly what we refer to as tidy since each observation (year-country combination) is associated with two, not one, rows. We want to have the values from the two variables, fertility and life expectancy, in two separate columns. The first challenge to achieve this is to separate the <code>key</code> column into the year and the variable type. Notice that the entries in this column separate the year from the variable name with an underscore:</p>
<pre class="r"><code>dat$key[1:5]</code></pre>
<pre><code>## [1] &quot;1960_fertility&quot;       &quot;1960_fertility&quot;       &quot;1960_life_expectancy&quot;
## [4] &quot;1960_life_expectancy&quot; &quot;1961_fertility&quot;</code></pre>
<p>Encoding multiple variables in a column name is such a common problem that the <strong>tidyverse</strong> package includes a function to separate these columns into two or more. Apart from the data, the <code>separate</code> function takes three arguments: the name of the column to be separated, the names to be used for the new columns, and the character that separates the variables. So, a first attempt at this is:</p>
<pre class="r"><code>dat %&gt;% separate(col = key, into = c(&quot;year&quot;, &quot;variable_name&quot;), sep = &quot;_&quot;)</code></pre>
<p>The function does separate the values, but we run into a new problem. We receive the warning <code>Additional pieces discarded in 112 rows [3, 4, 7,...]</code>. (Earlier versions may give the error <code>Too many values at 112 locations:</code>) and that the <code>life_expectancy</code> variable is truncated to <code>life</code>. This is because the <code>_</code> is used to separate <code>life</code> and <code>expectancy</code>, not just year and variable name! We could add a third column to catch this and let the <code>separate</code> function know which column to <em>fill in</em> with missing values, <code>NA</code>, when there is no third value. Here we tell it to fill the column on the right:</p>
<pre class="r"><code>dat %&gt;% separate(key, into = c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 224 x 5
##    country     year  first_variable_name second_variable_name value
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;               &lt;chr&gt;                &lt;dbl&gt;
##  1 Germany     1960  fertility           &lt;NA&gt;                  2.41
##  2 South Korea 1960  fertility           &lt;NA&gt;                  6.16
##  3 Germany     1960  life                expectancy           69.3 
##  4 South Korea 1960  life                expectancy           53.0 
##  5 Germany     1961  fertility           &lt;NA&gt;                  2.44
##  6 South Korea 1961  fertility           &lt;NA&gt;                  5.99
##  7 Germany     1961  life                expectancy           69.8 
##  8 South Korea 1961  life                expectancy           53.8 
##  9 Germany     1962  fertility           &lt;NA&gt;                  2.47
## 10 South Korea 1962  fertility           &lt;NA&gt;                  5.79
## # ... with 214 more rows</code></pre>
<p>However, if we read the <code>separate</code> help file, we find that a better approach is to merge the last two variables when there is an extra separation:</p>
<pre class="r"><code>dat %&gt;% separate(key, into = c(&quot;year&quot;, &quot;variable_name&quot;), extra = &quot;merge&quot;)</code></pre>
<pre><code>## # A tibble: 224 x 4
##    country     year  variable_name   value
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;
##  1 Germany     1960  fertility        2.41
##  2 South Korea 1960  fertility        6.16
##  3 Germany     1960  life_expectancy 69.3 
##  4 South Korea 1960  life_expectancy 53.0 
##  5 Germany     1961  fertility        2.44
##  6 South Korea 1961  fertility        5.99
##  7 Germany     1961  life_expectancy 69.8 
##  8 South Korea 1961  life_expectancy 53.8 
##  9 Germany     1962  fertility        2.47
## 10 South Korea 1962  fertility        5.79
## # ... with 214 more rows</code></pre>
<p>This achieves the separation we wanted. However, we are not done yet. We need to create a column for each variable. As we learned, the <code>spread</code> function can do this:</p>
<pre class="r"><code>dat %&gt;%
  separate(key, c(&quot;year&quot;, &quot;variable_name&quot;), extra = &quot;merge&quot;) %&gt;%
  spread(variable_name, value)</code></pre>
<pre><code>## # A tibble: 112 x 4
##    country year  fertility life_expectancy
##    &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;           &lt;dbl&gt;
##  1 Germany 1960       2.41            69.3
##  2 Germany 1961       2.44            69.8
##  3 Germany 1962       2.47            70.0
##  4 Germany 1963       2.49            70.1
##  5 Germany 1964       2.49            70.7
##  6 Germany 1965       2.48            70.6
##  7 Germany 1966       2.44            70.8
##  8 Germany 1967       2.37            71.0
##  9 Germany 1968       2.28            70.6
## 10 Germany 1969       2.17            70.5
## # ... with 102 more rows</code></pre>
<p>The data is now in tidy format with one row for each observation with three variables: year, fertility, and life expectancy.</p>
</div>
<div id="unite" class="section level2">
<h2><code>unite</code></h2>
<p>It is sometimes useful to do the inverse of <code>separate</code>, unite two columns into one. To demonstrate how to use <code>unite</code>, we show code that, although <em>not</em> the optimal approach, serves as an illustration. Suppose that we did not know about <code>extra</code> and used this command to separate:</p>
<pre class="r"><code>dat %&gt;%
  separate(key, c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 224 x 5
##    country     year  first_variable_name second_variable_name value
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;               &lt;chr&gt;                &lt;dbl&gt;
##  1 Germany     1960  fertility           &lt;NA&gt;                  2.41
##  2 South Korea 1960  fertility           &lt;NA&gt;                  6.16
##  3 Germany     1960  life                expectancy           69.3 
##  4 South Korea 1960  life                expectancy           53.0 
##  5 Germany     1961  fertility           &lt;NA&gt;                  2.44
##  6 South Korea 1961  fertility           &lt;NA&gt;                  5.99
##  7 Germany     1961  life                expectancy           69.8 
##  8 South Korea 1961  life                expectancy           53.8 
##  9 Germany     1962  fertility           &lt;NA&gt;                  2.47
## 10 South Korea 1962  fertility           &lt;NA&gt;                  5.79
## # ... with 214 more rows</code></pre>
<p>We can achieve the same final result by uniting the second and third columns, then spreading the columns and renaming <code>fertility_NA</code> to <code>fertility</code>:</p>
<pre class="r"><code>dat %&gt;%
  separate(key, c(&quot;year&quot;, &quot;first_variable_name&quot;, &quot;second_variable_name&quot;), fill = &quot;right&quot;) %&gt;%
  unite(variable_name, first_variable_name, second_variable_name) %&gt;%
  spread(variable_name, value) %&gt;%
  rename(fertility = fertility_NA)</code></pre>
<pre><code>## # A tibble: 112 x 4
##    country year  fertility life_expectancy
##    &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;           &lt;dbl&gt;
##  1 Germany 1960       2.41            69.3
##  2 Germany 1961       2.44            69.8
##  3 Germany 1962       2.47            70.0
##  4 Germany 1963       2.49            70.1
##  5 Germany 1964       2.49            70.7
##  6 Germany 1965       2.48            70.6
##  7 Germany 1966       2.44            70.8
##  8 Germany 1967       2.37            71.0
##  9 Germany 1968       2.28            70.6
## 10 Germany 1969       2.17            70.5
## # ... with 102 more rows</code></pre>
<div class="fyi">
<p><strong>TRY IT</strong></p>
<ol style="list-style-type: decimal">
<li>Run the following command to define the <code>co2_wide</code> object using the <code>co2</code> data built in to R (see <code>?co2</code>):</li>
</ol>
<pre class="r"><code>co2_wide &lt;- data.frame(matrix(co2, ncol = 12, byrow = TRUE)) %&gt;%
  setNames(1:12) %&gt;%
  mutate(year = as.character(1959:1997))</code></pre>
<p>Use the gather function to wrangle this into a tidy dataset. Call the column with the CO2 measurements <code>co2</code> and call the month column <code>month</code>. Call the resulting object <code>co2_tidy</code>.</p>
<ol start="2" style="list-style-type: decimal">
<li>Plot CO2 versus month with a different curve for each year using this code:</li>
</ol>
<pre class="r"><code>co2_tidy %&gt;% ggplot(aes(month, co2, color = year)) + geom_line()</code></pre>
<p>If the expected plot is not made, it is probably because <code>co2_tidy$month</code> is not numeric:</p>
<pre class="r"><code>class(co2_tidy$month)</code></pre>
<p>Rewrite the call to gather using an argument that assures the month column will be numeric. Then make the plot.</p>
<ol start="3" style="list-style-type: decimal">
<li>What do we learn from this plot?</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>CO2 measures increase monotonically from 1959 to 1997.</li>
<li>CO2 measures are higher in the summer and the yearly average increased from 1959 to 1997.</li>
<li>CO2 measures appear constant and random variability explains the differences.</li>
<li>CO2 measures do not have a seasonal trend.</li>
</ol>
<ol start="4" style="list-style-type: decimal">
<li>Now load the <code>admissions</code> data set, which contains admission information for men and women across six majors and keep only the admitted percentage column:</li>
</ol>
<pre class="r"><code>load(admissions)
dat &lt;- admissions %&gt;% dplyr::select(-applicants)</code></pre>
<p>If we think of an observation as a major, and that each observation has two variables (men admitted percentage and women admitted percentage) then this is not tidy. Use the <code>spread</code> function to wrangle into tidy shape: one row for each major.</p>
<ol start="5" style="list-style-type: decimal">
<li>Now we will try a more advanced wrangling challenge. We want to wrangle the admissions data so that for each major we have 4 observations: <code>admitted_men</code>, <code>admitted_women</code>, <code>applicants_men</code> and <code>applicants_women</code>. The <em>trick</em> we perform here is actually quite common: first gather to generate an intermediate data frame and then spread to obtain the tidy data we want. We will go step by step in this and the next two exercises.</li>
</ol>
<p>Use the gather function to create a <code>tmp</code> data.frame with a column containing the type of observation <code>admitted</code> or <code>applicants</code>. Call the new columns <code>key</code> and value.</p>
<ol start="6" style="list-style-type: decimal">
<li><p>Now you have an object <code>tmp</code> with columns <code>major</code>, <code>gender</code>, <code>key</code> and <code>value</code>. Note that if you combine the key and gender, we get the column names we want: <code>admitted_men</code>, <code>admitted_women</code>, <code>applicants_men</code> and <code>applicants_women</code>. Use the function <code>unite</code> to create a new column called <code>column_name</code>.</p></li>
<li><p>Now use the <code>spread</code> function to generate the tidy data with four variables for each major.</p></li>
<li><p>Now use the pipe to write a line of code that turns <code>admissions</code> to the table produced in the previous exercise.</p></li>
</ol>
</div>
</div>
</div>
<div id="joining-tables" class="section level1">
<h1>Joining tables</h1>
<p>The information we need for a given analysis may not be just in one table. For example, when forecasting elections we used the function <code>left_join</code> to combine the information from two tables. We also saw this in action using the <code>WDI</code> function (technically, the <code>WDI</code> API) in Project 2. Here we use a simpler example to illustrate the general challenge of combining tables.</p>
<p>Suppose we want to explore the relationship between population size for US states and electoral votes. We have the population size in this table:</p>
<pre class="r"><code>library(tidyverse)
library(dslabs)
data(murders)
head(murders)</code></pre>
<pre><code>##        state abb region population total
## 1    Alabama  AL  South    4779736   135
## 2     Alaska  AK   West     710231    19
## 3    Arizona  AZ   West    6392017   232
## 4   Arkansas  AR  South    2915918    93
## 5 California  CA   West   37253956  1257
## 6   Colorado  CO   West    5029196    65</code></pre>
<p>and electoral votes in this one:</p>
<pre class="r"><code>data(polls_us_election_2016)
head(results_us_election_2016)</code></pre>
<pre><code>##          state electoral_votes clinton trump others
## 1   California              55    61.7  31.6    6.7
## 2        Texas              38    43.2  52.2    4.5
## 3      Florida              29    47.8  49.0    3.2
## 4     New York              29    59.0  36.5    4.5
## 5     Illinois              20    55.8  38.8    5.4
## 6 Pennsylvania              20    47.9  48.6    3.6</code></pre>
<p>Just concatenating these two tables together will not work since the order of the states is not the same.</p>
<pre class="r"><code>identical(results_us_election_2016$state, murders$state)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>The <em>join</em> functions, described below, are designed to handle this challenge.</p>
<div id="joins" class="section level2">
<h2>Joins</h2>
<p>The <em>join</em> functions in the <strong>dplyr</strong> package (part of the tidyverse) make sure that the tables are combined so that matching rows are together. If you know SQL, you will see that the approach and syntax is very similar. The general idea is that one needs to identify one or more columns that will serve to match the two tables. Then a new table with the combined information is returned. Notice what happens if we join the two tables above by state using <code>left_join</code> (we will remove the <code>others</code> column and rename <code>electoral_votes</code> so that the tables fit on the page):</p>
<pre class="r"><code>tab &lt;- left_join(murders, results_us_election_2016, by = &quot;state&quot;) %&gt;%
  dplyr::select(-others) %&gt;% 
  rename(ev = electoral_votes)
head(tab)</code></pre>
<pre><code>##        state abb region population total ev clinton trump
## 1    Alabama  AL  South    4779736   135  9    34.4  62.1
## 2     Alaska  AK   West     710231    19  3    36.6  51.3
## 3    Arizona  AZ   West    6392017   232 11    45.1  48.7
## 4   Arkansas  AR  South    2915918    93  6    33.7  60.6
## 5 California  CA   West   37253956  1257 55    61.7  31.6
## 6   Colorado  CO   West    5029196    65  9    48.2  43.3</code></pre>
<p>The data has been successfully joined and we can now, for example, make a plot to explore the relationship:</p>
<pre class="r"><code>library(ggrepel)
tab %&gt;% ggplot(aes(population/10^6, ev, label = abb)) +
  geom_point() +
  geom_text_repel() +
  scale_x_continuous(trans = &quot;log2&quot;) +
  scale_y_continuous(trans = &quot;log2&quot;) +
  geom_smooth(method = &quot;lm&quot;, se = FALSE)</code></pre>
<p><img src="/content/11-content_files/figure-html/ev-vs-population-1.png" width="672" /></p>
<p>We see the relationship is close to linear with about 2 electoral votes for every million persons, but with very small states getting higher ratios.</p>
<p>In practice, it is not always the case that each row in one table has a matching row in the other. For this reason, we have several versions of join. To illustrate this challenge, we will take subsets of the tables above. We create the tables <code>tab1</code> and <code>tab2</code> so that they have some states in common but not all:</p>
<pre class="r"><code>tab_1 &lt;- slice(murders, 1:6) %&gt;% dplyr::select(state, population)
tab_1</code></pre>
<pre><code>##        state population
## 1    Alabama    4779736
## 2     Alaska     710231
## 3    Arizona    6392017
## 4   Arkansas    2915918
## 5 California   37253956
## 6   Colorado    5029196</code></pre>
<pre class="r"><code>tab_2 &lt;- results_us_election_2016 %&gt;%
  dplyr::filter(state%in%c(&quot;Alabama&quot;, &quot;Alaska&quot;, &quot;Arizona&quot;,
                    &quot;California&quot;, &quot;Connecticut&quot;, &quot;Delaware&quot;)) %&gt;%
  dplyr::select(state, electoral_votes) %&gt;% rename(ev = electoral_votes)
tab_2</code></pre>
<pre><code>##         state ev
## 1  California 55
## 2     Arizona 11
## 3     Alabama  9
## 4 Connecticut  7
## 5      Alaska  3
## 6    Delaware  3</code></pre>
<p>We will use these two tables as examples in the next sections.</p>
<div id="left-join" class="section level3">
<h3>Left join</h3>
<p>Suppose we want a table like <code>tab_1</code>, but adding electoral votes to whatever states we have available. For this, we use <code>left_join</code> with <code>tab_1</code> as the first argument. We specify which column to use to match with the <code>by</code> argument.</p>
<pre class="r"><code>left_join(tab_1, tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##        state population ev
## 1    Alabama    4779736  9
## 2     Alaska     710231  3
## 3    Arizona    6392017 11
## 4   Arkansas    2915918 NA
## 5 California   37253956 55
## 6   Colorado    5029196 NA</code></pre>
<p>Note that <code>NA</code>s are added to the two states not appearing in <code>tab_2</code>. Also, notice that this function, as well as all the other joins, can receive the first arguments through the pipe:</p>
<pre class="r"><code>tab_1 %&gt;% left_join(tab_2, by = &quot;state&quot;)</code></pre>
</div>
<div id="right-join" class="section level3">
<h3>Right join</h3>
<p>If instead of a table with the same rows as first table, we want one with the same rows as second table, we can use <code>right_join</code>:</p>
<pre class="r"><code>tab_1 %&gt;% right_join(tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##         state population ev
## 1     Alabama    4779736  9
## 2      Alaska     710231  3
## 3     Arizona    6392017 11
## 4  California   37253956 55
## 5 Connecticut         NA  7
## 6    Delaware         NA  3</code></pre>
<p>Now the NAs are in the column coming from <code>tab_1</code>.</p>
</div>
<div id="inner-join" class="section level3">
<h3>Inner join</h3>
<p>If we want to keep only the rows that have information in both tables, we use <code>inner_join</code>. You can think of this as an intersection:</p>
<pre class="r"><code>inner_join(tab_1, tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##        state population ev
## 1    Alabama    4779736  9
## 2     Alaska     710231  3
## 3    Arizona    6392017 11
## 4 California   37253956 55</code></pre>
</div>
<div id="full-join" class="section level3">
<h3>Full join</h3>
<p>If we want to keep all the rows and fill the missing parts with NAs, we can use <code>full_join</code>. You can think of this as a union:</p>
<pre class="r"><code>full_join(tab_1, tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##         state population ev
## 1     Alabama    4779736  9
## 2      Alaska     710231  3
## 3     Arizona    6392017 11
## 4    Arkansas    2915918 NA
## 5  California   37253956 55
## 6    Colorado    5029196 NA
## 7 Connecticut         NA  7
## 8    Delaware         NA  3</code></pre>
</div>
<div id="semi-join" class="section level3">
<h3>Semi join</h3>
<p>The <code>semi_join</code> function lets us keep the part of first table for which we have information in the second. It does not add the columns of the second. It isn’t often used:</p>
<pre class="r"><code>semi_join(tab_1, tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##        state population
## 1    Alabama    4779736
## 2     Alaska     710231
## 3    Arizona    6392017
## 4 California   37253956</code></pre>
<p>This gives the same result as:</p>
<pre class="r"><code>tab_1 %&gt;% 
  filter(state %in% tab_2$state) </code></pre>
<pre><code>##        state population
## 1    Alabama    4779736
## 2     Alaska     710231
## 3    Arizona    6392017
## 4 California   37253956</code></pre>
</div>
<div id="anti-join" class="section level3">
<h3>Anti join</h3>
<p>The function <code>anti_join</code> is the opposite of <code>semi_join</code>. It keeps the elements of the first table for which there is no information in the second:</p>
<pre class="r"><code>anti_join(tab_1, tab_2, by = &quot;state&quot;)</code></pre>
<pre><code>##      state population
## 1 Arkansas    2915918
## 2 Colorado    5029196</code></pre>
<p>The following diagram summarizes the above joins:</p>
<p><img src="/./11-content_files/joins.png" /></p>
<p><img src="img/joins.png" /></p>
<p>(Image courtesy of RStudio<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. CC-BY-4.0 license<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>. Cropped from original.)</p>
</div>
</div>
<div id="binding" class="section level2">
<h2>Binding</h2>
<p>Although we have yet to use it in this book, another common way in which datasets are combined is by <em>binding</em> them. Unlike the join function, the binding functions do not try to match by a variable, but instead simply combine datasets. If the datasets don’t match by the appropriate dimensions, one obtains an error.</p>
<div id="binding-columns" class="section level3">
<h3>Binding columns</h3>
<p>The <strong>dplyr</strong> function <em>bind_cols</em> binds two objects by making them columns in a tibble. For example, we quickly want to make a data frame consisting of numbers we can use.</p>
<pre class="r"><code>bind_cols(a = 1:3, b = 4:6)</code></pre>
<pre><code>## # A tibble: 3 x 2
##       a     b
##   &lt;int&gt; &lt;int&gt;
## 1     1     4
## 2     2     5
## 3     3     6</code></pre>
<p>This function requires that we assign names to the columns. Here we chose <code>a</code> and <code>b</code>.</p>
<p>Note that there is an R-base function <code>cbind</code> with the exact same functionality. An important difference is that <code>cbind</code> can create different types of objects, while <code>bind_cols</code> always produces a data frame.</p>
<p><code>bind_cols</code> can also bind two different data frames. For example, here we break up the <code>tab</code> data frame and then bind them back together:</p>
<pre class="r"><code>tab_1 &lt;- tab[, 1:3]
tab_2 &lt;- tab[, 4:6]
tab_3 &lt;- tab[, 7:8]
new_tab &lt;- bind_cols(tab_1, tab_2, tab_3)
head(new_tab)</code></pre>
<pre><code>##        state abb region population total ev clinton trump
## 1    Alabama  AL  South    4779736   135  9    34.4  62.1
## 2     Alaska  AK   West     710231    19  3    36.6  51.3
## 3    Arizona  AZ   West    6392017   232 11    45.1  48.7
## 4   Arkansas  AR  South    2915918    93  6    33.7  60.6
## 5 California  CA   West   37253956  1257 55    61.7  31.6
## 6   Colorado  CO   West    5029196    65  9    48.2  43.3</code></pre>
</div>
<div id="binding-by-rows" class="section level3">
<h3>Binding by rows</h3>
<p>The <code>bind_rows</code> function is similar to <code>bind_cols</code>, but binds rows instead of columns:</p>
<pre class="r"><code>tab_1 &lt;- tab[1:2,]
tab_2 &lt;- tab[3:4,]
bind_rows(tab_1, tab_2)</code></pre>
<pre><code>##      state abb region population total ev clinton trump
## 1  Alabama  AL  South    4779736   135  9    34.4  62.1
## 2   Alaska  AK   West     710231    19  3    36.6  51.3
## 3  Arizona  AZ   West    6392017   232 11    45.1  48.7
## 4 Arkansas  AR  South    2915918    93  6    33.7  60.6</code></pre>
<p>This is based on an R-base function <code>rbind</code>.</p>
</div>
</div>
<div id="set-operators" class="section level2">
<h2>Set operators</h2>
<p>Another set of commands useful for combining datasets are the set operators. When applied to vectors, these behave as their names suggest. Examples are <code>intersect</code>, <code>union</code>, <code>setdiff</code>, and <code>setequal</code>. However, if the <strong>tidyverse</strong>, or more specifically <strong>dplyr</strong>, is loaded, these functions can be used on data frames as opposed to just on vectors.</p>
<div id="intersect" class="section level3">
<h3>Intersect</h3>
<p>You can take intersections of vectors of any type, such as numeric:</p>
<pre class="r"><code>intersect(1:10, 6:15)</code></pre>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<p>or characters:</p>
<pre class="r"><code>intersect(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), c(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;))</code></pre>
<pre><code>## [1] &quot;b&quot; &quot;c&quot;</code></pre>
<p>The <strong>dplyr</strong> package includes an <code>intersect</code> function that can be applied to tables with the same column names. This function returns the rows in common between two tables. To make sure we use the <strong>dplyr</strong> version of <code>intersect</code> rather than the base package version, we can use <code>dplyr::intersect</code> like this:</p>
<pre class="r"><code>tab_1 &lt;- tab[1:5,]
tab_2 &lt;- tab[3:7,]
dplyr::intersect(tab_1, tab_2)</code></pre>
<pre><code>##        state abb region population total ev clinton trump
## 1    Arizona  AZ   West    6392017   232 11    45.1  48.7
## 2   Arkansas  AR  South    2915918    93  6    33.7  60.6
## 3 California  CA   West   37253956  1257 55    61.7  31.6</code></pre>
</div>
<div id="union" class="section level3">
<h3>Union</h3>
<p>Similarly <em>union</em> takes the union of vectors. For example:</p>
<pre class="r"><code>union(1:10, 6:15)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<pre class="r"><code>union(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), c(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;))</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</code></pre>
<p>The <strong>dplyr</strong> package includes a version of <code>union</code> that combines all the rows of two tables with the same column names.</p>
<pre class="r"><code>tab_1 &lt;- tab[1:5,]
tab_2 &lt;- tab[3:7,]
dplyr::union(tab_1, tab_2)</code></pre>
<pre><code>##         state abb    region population total ev clinton trump
## 1     Alabama  AL     South    4779736   135  9    34.4  62.1
## 2      Alaska  AK      West     710231    19  3    36.6  51.3
## 3     Arizona  AZ      West    6392017   232 11    45.1  48.7
## 4    Arkansas  AR     South    2915918    93  6    33.7  60.6
## 5  California  CA      West   37253956  1257 55    61.7  31.6
## 6    Colorado  CO      West    5029196    65  9    48.2  43.3
## 7 Connecticut  CT Northeast    3574097    97  7    54.6  40.9</code></pre>
<p>Note that we get 7 unique rows from this. We do not get duplicated rows from the overlap in <code>1:5</code> and <code>3:7</code>. If we were to <code>bind_rows</code> on the two subsets, we would get duplicates.</p>
</div>
<div id="setdiff" class="section level3">
<h3><code>setdiff</code></h3>
<p>The set difference between a first and second argument can be obtained with <code>setdiff</code>. Unlike <code>intersect</code> and <code>union</code>, this function is not symmetric:</p>
<pre class="r"><code>setdiff(1:10, 6:15)</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>setdiff(6:15, 1:10)</code></pre>
<pre><code>## [1] 11 12 13 14 15</code></pre>
<p>As with the functions shown above, <strong>dplyr</strong> has a version for data frames:</p>
<pre class="r"><code>tab_1 &lt;- tab[1:5,]
tab_2 &lt;- tab[3:7,]
dplyr::setdiff(tab_1, tab_2)</code></pre>
<pre><code>##     state abb region population total ev clinton trump
## 1 Alabama  AL  South    4779736   135  9    34.4  62.1
## 2  Alaska  AK   West     710231    19  3    36.6  51.3</code></pre>
</div>
<div id="setequal" class="section level3">
<h3><code>setequal</code></h3>
<p>Finally, the function <code>setequal</code> tells us if two sets are the same, regardless of order. So notice that:</p>
<pre class="r"><code>setequal(1:5, 1:6)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>but:</p>
<pre class="r"><code>setequal(1:5, 5:1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>When applied to data frames that are not equal, regardless of order, the <strong>dplyr</strong> version provides a useful message letting us know how the sets are different:</p>
<pre class="r"><code>dplyr::setequal(tab_1, tab_2)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<div class="fyi">
<p><strong>TRY IT</strong></p>
<ol style="list-style-type: decimal">
<li>Install and load the <strong>Lahman</strong> library. This database includes data related to baseball teams. It includes summary statistics about how the players performed on offense and defense for several years. It also includes personal information about the players.</li>
</ol>
<p>The <code>Batting</code> data frame contains the offensive statistics for all players for many years. You can see, for example, the top 10 hitters by running this code:</p>
<pre class="r"><code>library(Lahman)

top &lt;- Batting %&gt;%
  dplyr::filter(yearID == 2016) %&gt;%
  arrange(desc(HR)) %&gt;%
  slice(1:10)

top %&gt;% as_tibble()</code></pre>
<p>But who are these players? We see an ID, but not the names. The player names are in this table</p>
<pre class="r"><code>Master %&gt;% as_tibble()</code></pre>
<p>We can see column names <code>nameFirst</code> and <code>nameLast</code>. Use the <code>left_join</code> function to create a table of the top home run hitters. The table should have <code>playerID</code>, first name, last name, and number of home runs (HR). Rewrite the object <code>top</code> with this new table.</p>
<ol start="2" style="list-style-type: decimal">
<li><p>Now use the <code>Salaries</code> data frame to add each player’s salary to the table you created in exercise 1. Note that salaries are different every year so make sure to filter for the year 2016, then use <code>right_join</code>. This time show first name, last name, team, HR, and salary.</p></li>
<li><p>In a previous exercise, we created a tidy version of the <code>co2</code> dataset:</p></li>
</ol>
<pre class="r"><code>co2_wide &lt;- data.frame(matrix(co2, ncol = 12, byrow = TRUE)) %&gt;%
  setNames(1:12) %&gt;%
  mutate(year = 1959:1997) %&gt;%
  gather(month, co2, -year, convert = TRUE)</code></pre>
<p>We want to see if the monthly trend is changing so we are going to remove the year effects and then plot the results. We will first compute the year averages. Use the <code>group_by</code> and <code>summarize</code> to compute the average co2 for each year. Save in an object called <code>yearly_avg</code>.</p>
<ol start="4" style="list-style-type: decimal">
<li><p>Now use the <code>left_join</code> function to add the yearly average to the <code>co2_wide</code> dataset. Then compute the residuals: observed co2 measure - yearly average.</p></li>
<li><p>Make a plot of the seasonal trends by year but only after removing the year effect.</p></li>
</ol>
</div>
</div>
</div>
<div id="a-note-about-merging-and-dupliacted-rows" class="section level2">
<h2>A note about merging and dupliacted rows</h2>
<p>When we merge data, we have to be very careful about duplicated rows. Specifically, we have to be certain that the fields we use to join on are unique <strong>or</strong> that we know they aren’t unique and intend to duplicate rows.</p>
<p>When we have tidy data, we have one row per observation. When we join data that has more than one row per observation, the new dataset will no longer be tidy. For instance:</p>
<pre class="r"><code>tidyData &lt;- bind_cols( state = c(&#39;MI&#39;,&#39;CA&#39;,&#39;MI&#39;,&#39;CA&#39;), 
                       year = c(2001, 2002, 2001, 2002),  
                       Arrests = c(10, 21, 30, 12))

notTidyData &lt;- bind_cols(state = c(&#39;MI&#39;,&#39;MI&#39;,&#39;MI&#39;,&#39;CA&#39;,&#39;CA&#39;,&#39;CA&#39;), 
                         County = c(&#39;Ingham&#39;,&#39;Clinton&#39;,&#39;Wayne&#39;,&#39;Orange&#39;,&#39;Los Angeles&#39;,&#39;Kern&#39;),
                         InNOut_locations = c(0,0,0,20, 31, 8))

head(tidyData)</code></pre>
<pre><code>## # A tibble: 4 x 3
##   state  year Arrests
##   &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 MI     2001      10
## 2 CA     2002      21
## 3 MI     2001      30
## 4 CA     2002      12</code></pre>
<pre class="r"><code>head(notTidyData)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   state County      InNOut_locations
##   &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;
## 1 MI    Ingham                     0
## 2 MI    Clinton                    0
## 3 MI    Wayne                      0
## 4 CA    Orange                    20
## 5 CA    Los Angeles               31
## 6 CA    Kern                       8</code></pre>
<p>If we use the only common field, <code>state</code> to merge <code>tidyData</code>, which is unique on <code>state</code> and <code>year</code>, to <code>notTidyData</code>, which is unique on <code>county</code>, then every time we see <code>state</code> in our “left” data, we will get <strong>all three counties in that state and for that year</strong>. Even worse, we will get the <code>InNOut_locations</code> tally repeated for every matching <code>state</code>!</p>
<pre class="r"><code>joinedData &lt;- left_join(tidyData, notTidyData, by = c(&#39;state&#39;))
joinedData</code></pre>
<pre><code>## # A tibble: 12 x 5
##    state  year Arrests County      InNOut_locations
##    &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;
##  1 MI     2001      10 Ingham                     0
##  2 MI     2001      10 Clinton                    0
##  3 MI     2001      10 Wayne                      0
##  4 CA     2002      21 Orange                    20
##  5 CA     2002      21 Los Angeles               31
##  6 CA     2002      21 Kern                       8
##  7 MI     2001      30 Ingham                     0
##  8 MI     2001      30 Clinton                    0
##  9 MI     2001      30 Wayne                      0
## 10 CA     2002      12 Orange                    20
## 11 CA     2002      12 Los Angeles               31
## 12 CA     2002      12 Kern                       8</code></pre>
<p>Because we asked for all columns of <code>tidyData</code> that matched (on <code>state</code>) in <code>notTidyData</code>, we get replicated <code>Arrests</code> - look at MI in 2001 in the first three rows. The original data had 10 Arrests in Michigan in 2001. Now, <em>for every MI County in <code>notTidyData</code>, we have replicated the statewide arrests!</em></p>
<pre class="r"><code>sum(joinedData$Arrests)</code></pre>
<pre><code>## [1] 219</code></pre>
<pre class="r"><code>sum(tidyData$Arrests)</code></pre>
<pre><code>## [1] 73</code></pre>
<p>Yikes! We now have 3x the number of arrests in our data.</p>
<pre class="r"><code>sum(joinedData$InNOut_locations)</code></pre>
<pre><code>## [1] 118</code></pre>
<pre class="r"><code>sum(notTidyData$InNOut_locations)</code></pre>
<pre><code>## [1] 59</code></pre>
<p>And while we might like that we have 3x the In-N-Out locations, we definitely think our data shouldn’t suddenly have more.</p>
<p>The reason this happens is that we do not have a unique <em>key</em> variable. In the <code>WDI</code> tip in Project 2, we didn’t have a single unique key variable - there were multiple values of <code>iso2</code> country code in the data because we had multiple years for each <code>iso2</code>. Thus, when we merged, use used <code>by = c('iso2','year')</code> because <strong>the <code>iso2</code> x <code>year</code> combination was the unique key</strong>.</p>
<p>The lesson is this: always know what your join is doing. Know your unique keys. Use <code>sum(duplicated(tidyData$key))</code> to see if all values are unique, or <code>NROW(unique(tidyData %&gt;% dplyr::select(key1, key2)))</code> to see if all rows are unique over the 2 keys (replacing “key1” and “key2” with your key fields).</p>
<p>If it shouldn’t add rows, then make sure the new data has the same number of rows as the old one, or use <code>setequal</code> to check.</p>
</div>
</div>
<div id="parsing-dates-and-times" class="section level1">
<h1>Parsing dates and times</h1>
<div id="the-date-data-type" class="section level2">
<h2>The date data type</h2>
<p>We have described three main types of vectors: numeric, character, and logical. In data science projects, we very often encounter variables that are dates. Although we can represent a date with a string, for example <code>November 2, 2017</code>, once we pick a reference day, referred to as the <em>epoch</em>, they can be converted to numbers by calculating the number of days since the epoch. Computer languages usually use January 1, 1970, as the epoch. So, for example, January 2, 2017 is day 1, December 31, 1969 is day -1, and November 2, 2017, is day 17,204.</p>
<p>Now how should we represent dates and times when analyzing data in R? We could just use days since the epoch, but then it is almost impossible to interpret. If I tell you it’s November 2, 2017, you know what this means immediately. If I tell you it’s day 17,204, you will be quite confused. Similar problems arise with times and even more complications can appear due to time zones.</p>
<p>For this reason, <code>R</code> defines a data type just for dates and times. We saw an example in the polls data:</p>
<pre class="r"><code>library(tidyverse)
library(dslabs)
data(&quot;polls_us_election_2016&quot;)
polls_us_election_2016$startdate %&gt;% head</code></pre>
<pre><code>## [1] &quot;2016-11-03&quot; &quot;2016-11-01&quot; &quot;2016-11-02&quot; &quot;2016-11-04&quot; &quot;2016-11-03&quot;
## [6] &quot;2016-11-03&quot;</code></pre>
<p>These look like strings, but they are not:</p>
<pre class="r"><code>class(polls_us_election_2016$startdate)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<p>Look at what happens when we convert them to numbers:</p>
<pre class="r"><code>as.numeric(polls_us_election_2016$startdate) %&gt;% head</code></pre>
<pre><code>## [1] 17108 17106 17107 17109 17108 17108</code></pre>
<p>It turns them into days since the epoch. The <code>as.Date</code> function can convert a character into a date. So to see that the epoch is day 0 we can type</p>
<pre class="r"><code>as.Date(&quot;1970-01-01&quot;) %&gt;% as.numeric</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Plotting functions, such as those in ggplot, are aware of the date format. This means that, for example, a scatterplot can use the numeric representation to decide on the position of the point, but include the string in the labels:</p>
<pre class="r"><code>polls_us_election_2016 %&gt;% dplyr::filter(pollster == &quot;Ipsos&quot; &amp; state ==&quot;U.S.&quot;) %&gt;%
  ggplot(aes(startdate, rawpoll_trump)) +
  geom_line()</code></pre>
<p><img src="/content/11-content_files/figure-html/rawpolls-vs-time-1.png" width="672" /></p>
<p>Note in particular that the month names are displayed, a very convenient feature.</p>
</div>
<div id="lubridate" class="section level2">
<h2>The lubridate package</h2>
<p>The <strong>tidyverse</strong> includes functionality for dealing with dates through the <strong>lubridate</strong> package.</p>
<pre class="r"><code>library(lubridate)</code></pre>
<p>We will take a random sample of dates to show some of the useful things one can do:</p>
<pre class="r"><code>set.seed(2002)
dates &lt;- sample(polls_us_election_2016$startdate, 10) %&gt;% sort
dates</code></pre>
<pre><code>##  [1] &quot;2016-05-31&quot; &quot;2016-08-08&quot; &quot;2016-08-19&quot; &quot;2016-09-22&quot; &quot;2016-09-27&quot;
##  [6] &quot;2016-10-12&quot; &quot;2016-10-24&quot; &quot;2016-10-26&quot; &quot;2016-10-29&quot; &quot;2016-10-30&quot;</code></pre>
<p>The functions <code>year</code>, <code>month</code> and <code>day</code> extract those values:</p>
<pre class="r"><code>tibble(date = dates,
       month = month(dates),
       day = day(dates),
       year = year(dates))</code></pre>
<pre><code>## # A tibble: 10 x 4
##    date       month   day  year
##    &lt;date&gt;     &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;
##  1 2016-05-31     5    31  2016
##  2 2016-08-08     8     8  2016
##  3 2016-08-19     8    19  2016
##  4 2016-09-22     9    22  2016
##  5 2016-09-27     9    27  2016
##  6 2016-10-12    10    12  2016
##  7 2016-10-24    10    24  2016
##  8 2016-10-26    10    26  2016
##  9 2016-10-29    10    29  2016
## 10 2016-10-30    10    30  2016</code></pre>
<p>We can also extract the month labels:</p>
<pre class="r"><code>month(dates, label = TRUE)</code></pre>
<pre><code>##  [1] May Aug Aug Sep Sep Oct Oct Oct Oct Oct
## 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec</code></pre>
<p>Another useful set of functions are the <em>parsers</em> that convert strings into dates. The function <code>ymd</code> assumes the dates are in the format YYYY-MM-DD and tries to parse as well as possible.</p>
<pre class="r"><code>x &lt;- c(20090101, &quot;2009-01-02&quot;, &quot;2009 01 03&quot;, &quot;2009-1-4&quot;,
       &quot;2009-1, 5&quot;, &quot;Created on 2009 1 6&quot;, &quot;200901 !!! 07&quot;)
ymd(x)</code></pre>
<pre><code>## [1] &quot;2009-01-01&quot; &quot;2009-01-02&quot; &quot;2009-01-03&quot; &quot;2009-01-04&quot; &quot;2009-01-05&quot;
## [6] &quot;2009-01-06&quot; &quot;2009-01-07&quot;</code></pre>
<p>A further complication comes from the fact that dates often come in different formats in which the order of year, month, and day are different. The preferred format is to show year (with all four digits), month (two digits), and then day, or what is called the ISO 8601. Specifically we use YYYY-MM-DD so that if we order the string, it will be ordered by date. You can see the function <code>ymd</code> returns them in this format.</p>
<p>But, what if you encounter dates such as “09/01/02”? This could be September 1, 2002 or January 2, 2009 or January 9, 2002.
In these cases, examining the entire vector of dates will help you determine what format it is by process of elimination. Once you know, you can use the many parses provided by <strong>lubridate</strong>.</p>
<p>For example, if the string is:</p>
<pre class="r"><code>x &lt;- &quot;09/01/02&quot;</code></pre>
<p>The <code>ymd</code> function assumes the first entry is the year, the second is the month, and the third is the day, so it converts it to:</p>
<pre class="r"><code>ymd(x)</code></pre>
<pre><code>## [1] &quot;2009-01-02&quot;</code></pre>
<p>The <code>mdy</code> function assumes the first entry is the month, then the day, then the year:</p>
<pre class="r"><code>mdy(x)</code></pre>
<pre><code>## [1] &quot;2002-09-01&quot;</code></pre>
<p>The <em>lubridate</em> package provides a function for every possibility:</p>
<pre class="r"><code>ydm(x)</code></pre>
<pre><code>## [1] &quot;2009-02-01&quot;</code></pre>
<pre class="r"><code>myd(x)</code></pre>
<pre><code>## [1] &quot;2001-09-02&quot;</code></pre>
<pre class="r"><code>dmy(x)</code></pre>
<pre><code>## [1] &quot;2002-01-09&quot;</code></pre>
<pre class="r"><code>dym(x)</code></pre>
<pre><code>## [1] &quot;2001-02-09&quot;</code></pre>
<p>The <strong>lubridate</strong> package is also useful for dealing with times. In R base, you can get the current time typing <code>Sys.time()</code>. The <strong>lubridate</strong> package provides a slightly more advanced function, <code>now</code>, that permits you to define the time zone:</p>
<pre class="r"><code>now()</code></pre>
<pre><code>## [1] &quot;2022-01-05 16:08:14 EST&quot;</code></pre>
<pre class="r"><code>now(&quot;GMT&quot;)</code></pre>
<pre><code>## [1] &quot;2022-01-05 21:08:14 GMT&quot;</code></pre>
<p>You can see all the available time zones with <code>OlsonNames()</code> function.</p>
<p>We can also extract hours, minutes, and seconds:</p>
<pre class="r"><code>now() %&gt;% hour()</code></pre>
<pre><code>## [1] 16</code></pre>
<pre class="r"><code>now() %&gt;% minute()</code></pre>
<pre><code>## [1] 8</code></pre>
<pre class="r"><code>now() %&gt;% second()</code></pre>
<pre><code>## [1] 14.90685</code></pre>
<p>The package also includes a function to parse strings into times as well as parsers for time objects that include dates:</p>
<pre class="r"><code>x &lt;- c(&quot;12:34:56&quot;)
hms(x)</code></pre>
<pre><code>## [1] &quot;12H 34M 56S&quot;</code></pre>
<pre class="r"><code>x &lt;- &quot;Nov/2/2012 12:34:56&quot;
mdy_hms(x)</code></pre>
<pre><code>## [1] &quot;2012-11-02 12:34:56 UTC&quot;</code></pre>
<p>This package has many other useful functions. We describe two of these here that we find particularly useful.</p>
<p>The <code>make_date</code> function can be used to quickly create a date object. It takes three arguments: year, month, day, hour, minute, seconds, and time zone defaulting to the epoch values on UTC time. So create an date object representing, for example, July 6, 2019 we write:</p>
<pre class="r"><code>make_date(2019, 7, 6)</code></pre>
<pre><code>## [1] &quot;2019-07-06&quot;</code></pre>
<p>To make a vector of January 1 for the 80s we write:</p>
<pre class="r"><code>make_date(1980:1989)</code></pre>
<pre><code>##  [1] &quot;1980-01-01&quot; &quot;1981-01-01&quot; &quot;1982-01-01&quot; &quot;1983-01-01&quot; &quot;1984-01-01&quot;
##  [6] &quot;1985-01-01&quot; &quot;1986-01-01&quot; &quot;1987-01-01&quot; &quot;1988-01-01&quot; &quot;1989-01-01&quot;</code></pre>
<p>Another very useful function is the <code>round_date</code>. It can be used to <em>round</em> dates to nearest year, quarter, month, week, day, hour, minutes, or seconds. So if we want to group all the polls by week of the year we can do the following:</p>
<pre class="r"><code>polls_us_election_2016 %&gt;%
  mutate(week = round_date(startdate, &quot;week&quot;)) %&gt;%
  group_by(week) %&gt;%
  summarize(margin = mean(rawpoll_clinton - rawpoll_trump)) %&gt;%
  qplot(week, margin, data = .)</code></pre>
<p><img src="/content/11-content_files/figure-html/poll-margin-versus-week-1.png" width="672" /></p>
<p>Date objects can be added to and subtracted from with <code>hours</code>, <code>minutes</code>, etc.</p>
<pre class="r"><code>startDate &lt;- ymd_hms(&#39;2021-06-14 12:20:57&#39;)

startDate + seconds(4)</code></pre>
<pre><code>## [1] &quot;2021-06-14 12:21:01 UTC&quot;</code></pre>
<pre class="r"><code>startDate + hours(1) + days(2) - seconds(10)</code></pre>
<pre><code>## [1] &quot;2021-06-16 13:20:47 UTC&quot;</code></pre>
<p>You can even calculate time differences in specific units:</p>
<pre class="r"><code>endDate = ymd_hms(&#39;2021-06-15 01:00:00&#39;)

endDate - startDate</code></pre>
<pre><code>## Time difference of 12.65083 hours</code></pre>
<pre class="r"><code>difftime(endDate, startDate, units = &#39;days&#39;)</code></pre>
<pre><code>## Time difference of 0.5271181 days</code></pre>
<p>Note that both of these result in a <code>difftime</code> object. You can use <code>as.numeric(difftime(endDate, startDate))</code> to get the numeric difference in times.</p>
<p>Sequences can be created as well:</p>
<pre class="r"><code>seq(from = startDate, to = endDate, by = &#39;hour&#39;)</code></pre>
<pre><code>##  [1] &quot;2021-06-14 12:20:57 UTC&quot; &quot;2021-06-14 13:20:57 UTC&quot;
##  [3] &quot;2021-06-14 14:20:57 UTC&quot; &quot;2021-06-14 15:20:57 UTC&quot;
##  [5] &quot;2021-06-14 16:20:57 UTC&quot; &quot;2021-06-14 17:20:57 UTC&quot;
##  [7] &quot;2021-06-14 18:20:57 UTC&quot; &quot;2021-06-14 19:20:57 UTC&quot;
##  [9] &quot;2021-06-14 20:20:57 UTC&quot; &quot;2021-06-14 21:20:57 UTC&quot;
## [11] &quot;2021-06-14 22:20:57 UTC&quot; &quot;2021-06-14 23:20:57 UTC&quot;
## [13] &quot;2021-06-15 00:20:57 UTC&quot;</code></pre>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://github.com/rstudio/cheatsheets" class="uri">https://github.com/rstudio/cheatsheets</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://github.com/rstudio/cheatsheets/blob/master/LICENSE" class="uri">https://github.com/rstudio/cheatsheets/blob/master/LICENSE</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p><a href="https://github.com/rstudio/cheatsheets" class="uri">https://github.com/rstudio/cheatsheets</a><a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><a href="https://github.com/rstudio/cheatsheets/blob/master/LICENSE" class="uri">https://github.com/rstudio/cheatsheets/blob/master/LICENSE</a><a href="#fnref4" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

                    </div>

                    



                    
                </div>

                <div class="body-footer">
                    <p>Last updated on April 4, 2021</p>

                    


                    

                </div>

            </article>

            <footer>
    <hr>

    <div class="row course-info">
        <div class="col-md-7">
            <p>
                <strong>SSC 442: Data Analytics (Spring Semester 2021)</strong><br>

                <a href="https://www.msu.edu" target="_blank" rel="noopener">Michigan State University</a> &emsp;&emsp;
                <a href="https://socialscience.msu.edu/" target="_blank" rel="noopener">College of Social Science</a>
            </p>

            <p>
                <a href="https://www.justinkirkpatrick.com" target="_blank" rel="noopener"><i class="fas fa-user"></i>
                    Prof. Justin Kirkpatrick</a> &emsp;&emsp;
                <a href="mailto:jkirk@msu.edu"><i class="fas fa-envelope"></i>
                    jkirk@msu.edu</a>
            </p>

            <p>
                <i class="far fa-calendar-alt"></i> Tuesday and Thursday &emsp;&emsp;
                <i class="far fa-clock"></i> 1:00pm - 2:20pm 
                
            </p>
        </div>

        <div class="col-md-5 credits">
            <p>All content licensed under a <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</p>
            
            <p>Content <i class="fab fa-creative-commons"></i> 2020-21 <a href="https://www.justinkirkpatrick.com" target="_blank" rel="noopener">Ben Bushong; Justin Kirkpatrick</a></p>
        
            <p>This site created with the <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> in <a href="https://bookdown.org/yihui/blogdown/" target="_blank" rel="noopener">blogdown</a> and <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>. </p>
            
            <p><a href="https://github.com/" target="_blank" rel="noopener"><i class="fab fa-github"></i> View the source at GitHub.</a></p>
        </div>
    </div>
</footer>


        </main>
    </div>
</div>

        

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/r.min.js"></script>
        
      

    

    
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    

    
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    <script src="/js/academic.min.6f7ce8be710290b8c431bbc97f405d15.js"></script>

    



    
    

    
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>

</html>
